import numba
import numpy as np

deg = 180.0 / np.pi
rad = np.pi / 180.0


@numba.njit(cache=True)
def matrix2para(matrix, radians=True):
    """
    Given a 3x3 matrix representing a unit cell, outputs a list of lattice
    parameters.

    Args:
        matrix: a 3x3 array or list, where the first, second, and third rows
            represent the a, b, and c vectors respectively
        radians: if True, outputs angles in radians. If False, outputs in
            degrees

    Returns:
        a 1x6 list of lattice parameters [a, b, c, alpha, beta, gamma]. a, b,
        and c are the length of the lattice vectos, and alpha, beta, and gamma
        are the angles between these vectors (in radians by default)
    """
    cell_para = np.zeros(6)
    # a
    cell_para[0] = np.linalg.norm(matrix[0])
    # b
    cell_para[1] = np.linalg.norm(matrix[1])
    # c
    cell_para[2] = np.linalg.norm(matrix[2])
    # alpha
    cell_para[3] = angle(matrix[1], matrix[2])
    # beta
    cell_para[4] = angle(matrix[0], matrix[2])
    # gamma
    cell_para[5] = angle(matrix[0], matrix[1])

    if not radians:
        # convert radians to degrees
        deg = 180.0 / np.pi
        cell_para[3] *= deg
        cell_para[4] *= deg
        cell_para[5] *= deg
    return cell_para


@numba.njit(cache=True)
def para2matrix(cell_para, radians=True, format="upper"):
    """
    Given a set of lattic parameters, generates a matrix representing the
    lattice vectors

    Args:
        cell_para: a 1x6 list of lattice parameters [a, b, c, alpha, beta,
            gamma]. a, b, and c are the length of the lattice vectos, and
            alpha, beta, and gamma are the angles between these vectors. Can
            be generated by matrix2para
        radians: if True, lattice parameters should be in radians. If False,
            lattice angles should be in degrees
        format: a string ('lower', 'symmetric', or 'upper') for the type of
            matrix to be output

    Returns:
        a 3x3 matrix representing the unit cell. By default (format='lower'),
        the a vector is aligined along the x-axis, and the b vector is in the
        y-z plane
    """
    a = cell_para[0]
    b = cell_para[1]
    c = cell_para[2]
    alpha = cell_para[3]
    beta = cell_para[4]
    gamma = cell_para[5]
    if radians is not True:
        alpha *= rad
        beta *= rad
        gamma *= rad
    cos_alpha = np.cos(alpha)
    cos_beta = np.cos(beta)
    cos_gamma = np.cos(gamma)
    sin_gamma = np.sin(gamma)
    sin_alpha = np.sin(alpha)
    matrix = np.zeros((3, 3))
    if format == "lower":
        # Generate a lower-diagonal matrix
        c1 = c * cos_beta
        c2 = (c * (cos_alpha - (cos_beta * cos_gamma))) / sin_gamma
        matrix[0][0] = a
        matrix[1][0] = b * cos_gamma
        matrix[1][1] = b * sin_gamma
        matrix[2][0] = c1
        matrix[2][1] = c2
        matrix[2][2] = np.sqrt(c**2 - c1**2 - c2**2)
    elif format == "symmetric":
        # TODO: allow generation of symmetric matrices
        pass
    elif format == "upper":
        # Generate an upper-diagonal matrix
        a3 = a * cos_beta
        a2 = (a * (cos_gamma - (cos_beta * cos_alpha))) / sin_alpha
        matrix[2][2] = c
        matrix[1][2] = b * cos_alpha
        matrix[1][1] = b * sin_alpha
        matrix[0][2] = a3
        matrix[0][1] = a2
        matrix[0][0] = np.sqrt(a**2 - a3**2 - a2**2)
        # pass
    return matrix


@numba.njit(cache=True)
def generate_lattice(
    ltype,
    volume,
    minvec=1.2,
    minangle=np.pi / 6,
    max_ratio=10.0,
    maxattempts=100,
):

    maxangle = np.pi - minangle

    for n in range(maxattempts):
        # Triclinic
        # if sg <= 2:
        if ltype == "triclinic":
            # Derive lattice constants from a random matrix
            mat = random_shear_matrix(width=0.2)
            a, b, c, alpha, beta, gamma = matrix2para(mat)
            x = np.sqrt(
                1
                - np.cos(alpha) ** 2
                - np.cos(beta) ** 2
                - np.cos(gamma) ** 2
                + 2 * (np.cos(alpha) * np.cos(beta) * np.cos(gamma))
            )
            vec = random_vector()
            abc = volume / x
            xyz = vec[0] * vec[1] * vec[2]
            a = vec[0] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            b = vec[1] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            c = vec[2] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
        # Monoclinic
        elif ltype in ["monoclinic", "Monoclinic"]:
            alpha, gamma = np.pi / 2, np.pi / 2
            beta = gaussian(minangle, maxangle)
            x = np.sin(beta)
            vec = random_vector()
            xyz = vec[0] * vec[1] * vec[2]
            abc = volume / x
            a = vec[0] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            b = vec[1] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            c = vec[2] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
        # Orthorhombic
        # elif sg <= 74:
        elif ltype in ["orthorhombic", "Orthorhombic"]:
            alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
            x = 1
            vec = random_vector()
            xyz = vec[0] * vec[1] * vec[2]
            abc = volume / x
            a = vec[0] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            b = vec[1] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            c = vec[2] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
        # Tetragonal
        # elif sg <= 142:
        elif ltype in ["tetragonal", "Tetragonal"]:
            alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
            x = 1
            vec = random_vector()
            c = vec[2] / (vec[0] * vec[1]) * (volume / x) ** (1 / 3)
            a = b = np.sqrt((volume / x) / c)
        # Trigonal/Rhombohedral/Hexagonal
        # elif sg <= 194:
        elif ltype in ["hexagonal", "trigonal", "rhombohedral"]:
            alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 3 * 2
            x = np.sqrt(3.0) / 2.0
            vec = random_vector()
            c = vec[2] / (vec[0] * vec[1]) * (volume / x) ** (1 / 3)
            a = b = np.sqrt((volume / x) / c)
        # Cubic
        # else:
        elif ltype in ["cubic", "Cubic"]:
            alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
            s = (volume) ** (1.0 / 3.0)
            a, b, c = s, s, s

        # Check that lattice meets requirements
        maxvec = (a * b * c) / (minvec**2)

        # Define limits on cell dimensions
        """
        if "min_l" not in kwargs:
            min_l = minvec
        else:
            min_l = kwargs["min_l"]
        if "mid_l" not in kwargs:
            mid_l = min_l
        else:
            mid_l = kwargs["mid_l"]
        if "max_l" not in kwargs:
            max_l = mid_l
        else:
            max_l = kwargs["max_l"]
        """
        # Defining cell dimensions not currently supported!
        min_l = minvec
        mid_l = minvec
        max_l = minvec

        l_min = min(a, b, c)
        l_max = max(a, b, c)
        for x in (a, b, c):
            if x <= l_max and x >= l_min:
                l_mid = x
        if not (l_min >= min_l and l_mid >= mid_l and l_max >= max_l):
            continue

        if minvec < maxvec:
            # Check minimum Euclidean distances
            smallvec = min(
                a * np.cos(max(beta, gamma)),
                b * np.cos(max(alpha, gamma)),
                c * np.cos(max(alpha, beta)),
            )
            if (
                a > minvec
                and b > minvec
                and c > minvec
                and a < maxvec
                and b < maxvec
                and c < maxvec
                and smallvec < minvec
                and alpha > minangle
                and beta > minangle
                and gamma > minangle
                and alpha < maxangle
                and beta < maxangle
                and gamma < maxangle
                and a / b < max_ratio
                and a / c < max_ratio
                and b / c < max_ratio
                and b / a < max_ratio
                and c / a < max_ratio
                and c / b < max_ratio
            ):
                return np.array([a, b, c, alpha, beta, gamma])

    # If maxattempts tries have been made without success
    msg = "Could not get lattice after many cycles"
    raise ValueError(msg)
    # return


@numba.njit(cache=True)
def generate_para(lattice_ltype, lattice_volume):
    return generate_lattice(
        lattice_ltype, lattice_volume
    )  # lattice_kwargs not supported here!


@numba.njit(cache=True)
def generate_matrix(lattice_ltype, lattice_volume):
    """
    Generates a 3x3 matrix for the lattice based on the lattice type and volume
    """

    # (Try multiple times in case of failure)
    # for i in range(10):
    para = generate_para(lattice_ltype, lattice_volume)
    return para2matrix(para)


@numba.njit(cache=True)
def reset_matrix(lattice_ltype, lattice_volume):
    for i in range(3):  # also try multiple times
        m = generate_matrix(lattice_ltype, lattice_volume)
        # if m is not None:
        # inv_matrix = np.linalg.inv(m)

        # [a, b, c, alpha, beta, gamma] = matrix2para(matrix)
        return matrix2para(m), m


def generate_pyxtal_object(
    group_object, factor, species, chosen_wyckoff_indices, multiplicities, max_volume
):

    # calculate the sum of covalent volumes
    # calculate actual volume of crystal (multiply by factor)
    # generate a lattice with the given volume
    # create the pyxtal object

    ########## Set the volume

    volume = 0
    for numIon, specie in zip(multiplicities, species):
        # r = random.uniform(
        #    Element(specie).covalent_radius, Element(specie).vdw_radius
        # )
        r = (Element(specie).covalent_radius + Element(specie).vdw_radius) / 2
        volume += numIon * 4 / 3 * np.pi * r**3
    volume = factor * volume

    # TODO: Think about this again!
    # make sure the volume is not too small
    if volume / sum(multiplicities) < self.min_density:
        volume = sum(multiplicities) * self.min_density
        print("Volume has been scaled to match minimum density.")

    (
        paras,
        lattice_matrix,
    ) = reset_matrix(lattice_ltype, volume)

    # TODO: Handle > max_volume
    # TODO: Handle lattice re-generation
