# Parts of this (especially the lattice generation) originate from the pyxtal codebase.
# https://github.com/qzhu2017/PyXtal


import numba
import numpy as np
from pyxtal.database.element import Element

deg = 180.0 / np.pi
rad = np.pi / 180.0


@numba.njit(cache=True)
def angle(v1, v2, radians=True):
    """
    Calculate the angle (in radians) between two vectors.

    Args:
        v1: a 1x3 vector
        v2: a 1x3 vector
        radians: whether to return angle in radians (default) or degrees

    Returns:
        the angle in radians between the two vectors
    """
    v1 = np.real(v1)
    v2 = np.real(v2)
    dot = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
    # if np.isclose(dot, 1.0):
    if np.abs(dot - 1) < 1e-3:
        a = 0
    elif np.abs(dot + 1) < 1e-3:
        a = np.pi
    else:
        a = np.arccos(dot)

    if radians:
        return a
    else:
        return a * deg


@numba.njit(cache=True)
def matrix2para(matrix, radians=True):
    """
    Given a 3x3 matrix representing a unit cell, outputs a list of lattice
    parameters.

    Args:
        matrix: a 3x3 array or list, where the first, second, and third rows
            represent the a, b, and c vectors respectively
        radians: if True, outputs angles in radians. If False, outputs in
            degrees

    Returns:
        a 1x6 list of lattice parameters [a, b, c, alpha, beta, gamma]. a, b,
        and c are the length of the lattice vectos, and alpha, beta, and gamma
        are the angles between these vectors (in radians by default)
    """
    cell_para = np.zeros(6)
    # a
    cell_para[0] = np.linalg.norm(matrix[0])
    # b
    cell_para[1] = np.linalg.norm(matrix[1])
    # c
    cell_para[2] = np.linalg.norm(matrix[2])
    # alpha
    cell_para[3] = angle(matrix[1], matrix[2])
    # beta
    cell_para[4] = angle(matrix[0], matrix[2])
    # gamma
    cell_para[5] = angle(matrix[0], matrix[1])

    if not radians:
        # convert radians to degrees
        deg = 180.0 / np.pi
        cell_para[3] *= deg
        cell_para[4] *= deg
        cell_para[5] *= deg
    return cell_para


@numba.njit(cache=True)
def para2matrix(cell_para, radians=True, format="upper"):
    """
    Given a set of lattic parameters, generates a matrix representing the
    lattice vectors

    Args:
        cell_para: a 1x6 list of lattice parameters [a, b, c, alpha, beta,
            gamma]. a, b, and c are the length of the lattice vectos, and
            alpha, beta, and gamma are the angles between these vectors. Can
            be generated by matrix2para
        radians: if True, lattice parameters should be in radians. If False,
            lattice angles should be in degrees
        format: a string ('lower', 'symmetric', or 'upper') for the type of
            matrix to be output

    Returns:
        a 3x3 matrix representing the unit cell. By default (format='lower'),
        the a vector is aligined along the x-axis, and the b vector is in the
        y-z plane
    """
    a = cell_para[0]
    b = cell_para[1]
    c = cell_para[2]
    alpha = cell_para[3]
    beta = cell_para[4]
    gamma = cell_para[5]
    if radians is not True:
        alpha *= rad
        beta *= rad
        gamma *= rad
    cos_alpha = np.cos(alpha)
    cos_beta = np.cos(beta)
    cos_gamma = np.cos(gamma)
    sin_gamma = np.sin(gamma)
    sin_alpha = np.sin(alpha)
    matrix = np.zeros((3, 3))
    if format == "lower":
        # Generate a lower-diagonal matrix
        c1 = c * cos_beta
        c2 = (c * (cos_alpha - (cos_beta * cos_gamma))) / sin_gamma
        matrix[0][0] = a
        matrix[1][0] = b * cos_gamma
        matrix[1][1] = b * sin_gamma
        matrix[2][0] = c1
        matrix[2][1] = c2
        matrix[2][2] = np.sqrt(c**2 - c1**2 - c2**2)
    elif format == "symmetric":
        # TODO: allow generation of symmetric matrices
        pass
    elif format == "upper":
        # Generate an upper-diagonal matrix
        a3 = a * cos_beta
        a2 = (a * (cos_gamma - (cos_beta * cos_alpha))) / sin_alpha
        matrix[2][2] = c
        matrix[1][2] = b * cos_alpha
        matrix[1][1] = b * sin_alpha
        matrix[0][2] = a3
        matrix[0][1] = a2
        matrix[0][0] = np.sqrt(a**2 - a3**2 - a2**2)
        # pass
    return matrix


@numba.njit(cache=True)
def random_shear_matrix(width=1.0, unitary=False):
    """
    Generate a random symmetric shear matrix with Gaussian elements. If unitary
    is True, normalize to determinant 1

    Args:
        width: the width of the normal distribution to use when choosing values.
            Passed to np.random.normal
        unitary: whether or not to normalize the matrix to determinant 1

    Returns:
        a 3x3 numpy array of floats
    """

    mat = np.zeros((3, 3))
    determinant = 0
    while determinant == 0:
        a, b, c = (
            np.random.normal(0.0, width),
            np.random.normal(0.0, width),
            np.random.normal(0.0, width),
        )
        mat = np.array([[1, a, b], [a, 1, c], [b, c, 1]])
        determinant = np.linalg.det(mat)
    if unitary:
        # new = mat / np.cbrt(np.linalg.det(mat))
        new = mat / (np.linalg.det(mat)) ** (1 / 3)
        return new
    else:
        return mat


@numba.njit(cache=True)
def random_vector(width=0.35, unit=False):
    """
    Generate a random vector for lattice constant generation. The ratios between
    x, y, and z of the returned vector correspond to the ratios between a, b,
    and c. Results in a Gaussian distribution of the natural log of the ratios.

    Args:
        minvec: the bottom-left-back minimum point which can be chosen
        maxvec: the top-right-front maximum point which can be chosen
        width: the width of the normal distribution to use when choosing values.
            Passed to np.random.normal
        unit: whether or not to normalize the vector to determinant 1

    Returns:
        a 1x3 numpy array of floats
    """

    vec = np.array(
        [
            np.exp(np.random.normal(0.0, width)),
            np.exp(np.random.normal(0.0, width)),
            np.exp(np.random.normal(0.0, width)),
        ],
        # dtype=numba.types.float64,
    )
    if unit:
        return vec / np.linalg.norm(vec)
    else:
        return vec


@numba.njit(cache=True)
def gaussian(min, max, sigma=3.0):
    """
    Choose a random number from a Gaussian probability distribution centered
    between min and max. sigma is the number of standard deviations that min
    and max are away from the center. Thus, sigma is also the largest possible
    number of standard deviations corresponding to the returned value. sigma=2
    corresponds to a 95.45% probability of choosing a number between min and
    max.

    Args:
        min: the minimum acceptable value
        max: the maximum acceptable value
        sigma: the number of standard deviations between the center and min or max

    Returns:
        a value chosen randomly between min and max
    """

    center = (max + min) * 0.5
    delta = np.fabs(max - min) * 0.5
    ratio = delta / sigma
    while True:
        x = np.random.normal(scale=ratio, loc=center)
        if x > min and x < max:
            return x


@numba.njit(cache=True)
def generate_lattice(
    ltype,
    volume,
    minvec=1.2,
    minangle=np.pi / 6,
    max_ratio=10.0,
    maxattempts=100,
):

    maxangle = np.pi - minangle

    for n in range(maxattempts):
        # Triclinic
        # if sg <= 2:
        if ltype == "triclinic":
            # Derive lattice constants from a random matrix
            mat = random_shear_matrix(width=0.2)
            a, b, c, alpha, beta, gamma = matrix2para(mat)
            x = np.sqrt(
                1
                - np.cos(alpha) ** 2
                - np.cos(beta) ** 2
                - np.cos(gamma) ** 2
                + 2 * (np.cos(alpha) * np.cos(beta) * np.cos(gamma))
            )
            vec = random_vector()
            abc = volume / x
            xyz = vec[0] * vec[1] * vec[2]
            a = vec[0] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            b = vec[1] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            c = vec[2] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
        # Monoclinic
        elif ltype in ["monoclinic", "Monoclinic"]:
            alpha, gamma = np.pi / 2, np.pi / 2
            beta = gaussian(minangle, maxangle)
            x = np.sin(beta)
            vec = random_vector()
            xyz = vec[0] * vec[1] * vec[2]
            abc = volume / x
            a = vec[0] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            b = vec[1] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            c = vec[2] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
        # Orthorhombic
        # elif sg <= 74:
        elif ltype in ["orthorhombic", "Orthorhombic"]:
            alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
            x = 1
            vec = random_vector()
            xyz = vec[0] * vec[1] * vec[2]
            abc = volume / x
            a = vec[0] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            b = vec[1] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
            c = vec[2] * (abc) ** (1 / 3) / (xyz) ** (1 / 3)
        # Tetragonal
        # elif sg <= 142:
        elif ltype in ["tetragonal", "Tetragonal"]:
            alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
            x = 1
            vec = random_vector()
            c = vec[2] / (vec[0] * vec[1]) * (volume / x) ** (1 / 3)
            a = b = np.sqrt((volume / x) / c)
        # Trigonal/Rhombohedral/Hexagonal
        # elif sg <= 194:
        elif ltype in ["hexagonal", "trigonal", "rhombohedral"]:
            alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 3 * 2
            x = np.sqrt(3.0) / 2.0
            vec = random_vector()
            c = vec[2] / (vec[0] * vec[1]) * (volume / x) ** (1 / 3)
            a = b = np.sqrt((volume / x) / c)
        # Cubic
        # else:
        elif ltype in ["cubic", "Cubic"]:
            alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
            s = (volume) ** (1.0 / 3.0)
            a, b, c = s, s, s

        # Check that lattice meets requirements
        maxvec = (a * b * c) / (minvec**2)

        # Define limits on cell dimensions
        """
        if "min_l" not in kwargs:
            min_l = minvec
        else:
            min_l = kwargs["min_l"]
        if "mid_l" not in kwargs:
            mid_l = min_l
        else:
            mid_l = kwargs["mid_l"]
        if "max_l" not in kwargs:
            max_l = mid_l
        else:
            max_l = kwargs["max_l"]
        """

        # Defining cell dimensions not currently supported!
        min_l = minvec
        mid_l = minvec
        max_l = minvec

        l_min = min(a, b, c)
        l_max = max(a, b, c)
        for x in (a, b, c):
            if x <= l_max and x >= l_min:
                l_mid = x
        if not (l_min >= min_l and l_mid >= mid_l and l_max >= max_l):
            continue

        if minvec < maxvec:
            # Check minimum Euclidean distances
            smallvec = min(
                a * np.cos(max(beta, gamma)),
                b * np.cos(max(alpha, gamma)),
                c * np.cos(max(alpha, beta)),
            )
            if (
                a > minvec
                and b > minvec
                and c > minvec
                and a < maxvec
                and b < maxvec
                and c < maxvec
                and smallvec < minvec
                and alpha > minangle
                and beta > minangle
                and gamma > minangle
                and alpha < maxangle
                and beta < maxangle
                and gamma < maxangle
                and a / b < max_ratio
                and a / c < max_ratio
                and b / c < max_ratio
                and b / a < max_ratio
                and c / a < max_ratio
                and c / b < max_ratio
            ):
                return np.array([a, b, c, alpha, beta, gamma])

    # If maxattempts tries have been made without success
    msg = "Could not get lattice after many cycles"
    raise ValueError(msg)
    # return


@numba.njit(cache=True)
def generate_para(lattice_ltype, lattice_volume):
    return generate_lattice(
        lattice_ltype, lattice_volume
    )  # lattice_kwargs not supported here!


@numba.njit(cache=True)
def generate_matrix(lattice_ltype, lattice_volume):
    """
    Generates a 3x3 matrix for the lattice based on the lattice type and volume
    """

    # (Try multiple times in case of failure)
    # for i in range(10):
    para = generate_para(lattice_ltype, lattice_volume)
    return para2matrix(para)


@numba.njit(cache=True)
def reset_matrix(lattice_ltype, lattice_volume):
    for i in range(3):  # also try multiple times
        m = generate_matrix(lattice_ltype, lattice_volume)
        # if m is not None:
        # inv_matrix = np.linalg.inv(m)

        # [a, b, c, alpha, beta, gamma] = matrix2para(matrix)
        return matrix2para(m), m


def generate_pyxtal_object(
    group_object, factor, species, chosen_wyckoff_indices, multiplicities, max_volume
):

    # calculate the sum of covalent volumes
    # calculate actual volume of crystal (multiply by factor)
    # generate a lattice with the given volume
    # create the pyxtal object

    ########## Set the volume

    volume = 0
    for numIon, specie in zip(multiplicities, species):
        # r = random.uniform(
        #    Element(specie).covalent_radius, Element(specie).vdw_radius
        # )
        r = (Element(specie).covalent_radius + Element(specie).vdw_radius) / 2
        volume += numIon * 4 / 3 * np.pi * r**3
    volume = factor * volume

    # TODO: Think about this again! Do we really need this?
    min_density = 0.75
    # make sure the volume is not too small
    if volume / sum(multiplicities) < min_density:
        volume = sum(multiplicities) * min_density
        print("Volume has been scaled to match minimum density.")

    (
        paras,
        lattice_matrix,
    ) = reset_matrix(lattice_ltype, volume)
    # TODO: Get lattice type (look how pyxtal handles this in "Lattice" constructor)

    # TODO: Handle > max_volume (return like the original implementation also did)

    # TODO: Handle lattice re-generation
    # Understand what the "merge" call is doing in the wyckoff object
